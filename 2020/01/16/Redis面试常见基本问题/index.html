<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Redis," />










<meta name="description" content="1.基础1.1 什么是Redis？Redis的全称是：Remote Dictionary Server，本质上是一个 Key-Value 类型的内存数据库。 整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据保存在硬盘。因为是纯内存操作，Redis 的性能非常出色。 1.2 Redis的优劣势？优势：  纯内存读写操作，性能好。 支持多种数据结构。 单线程，不用担心竞争 特性丰富，">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis面试常见基本问题">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;01&#x2F;16&#x2F;Redis%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98&#x2F;index.html">
<meta property="og:site_name" content="gzlBlog">
<meta property="og:description" content="1.基础1.1 什么是Redis？Redis的全称是：Remote Dictionary Server，本质上是一个 Key-Value 类型的内存数据库。 整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据保存在硬盘。因为是纯内存操作，Redis 的性能非常出色。 1.2 Redis的优劣势？优势：  纯内存读写操作，性能好。 支持多种数据结构。 单线程，不用担心竞争 特性丰富，">
<meta property="og:image" content="https:&#x2F;&#x2F;uk-1259555870.cos.eu-frankfurt.myqcloud.com&#x2F;20200113150533.png">
<meta property="og:image" content="https:&#x2F;&#x2F;uk-1259555870.cos.eu-frankfurt.myqcloud.com&#x2F;20200113152209.png">
<meta property="og:image" content="https:&#x2F;&#x2F;uk-1259555870.cos.eu-frankfurt.myqcloud.com&#x2F;20200113154703.png">
<meta property="og:image" content="https:&#x2F;&#x2F;uk-1259555870.cos.eu-frankfurt.myqcloud.com&#x2F;20200113160426.png">
<meta property="og:image" content="https:&#x2F;&#x2F;cdn.cnbj1.fds.api.mi-img.com&#x2F;book&#x2F;images&#x2F;fcccd0065c411e2492d097f9bb0fb378?thumb&#x3D;1&amp;w&#x3D;1024&amp;h&#x3D;1024">
<meta property="og:image" content="https:&#x2F;&#x2F;cdn.cnbj1.fds.api.mi-img.com&#x2F;book&#x2F;images&#x2F;7fb4b031c86ff72f6478b8e16718b43d?thumb&#x3D;1&amp;w&#x3D;1024&amp;h&#x3D;1024">
<meta property="og:image" content="https:&#x2F;&#x2F;uk-1259555870.cos.eu-frankfurt.myqcloud.com&#x2F;20200112133931.png">
<meta property="og:image" content="https:&#x2F;&#x2F;uk-1259555870.cos.eu-frankfurt.myqcloud.com&#x2F;20200112105535.png">
<meta property="article:published_time" content="2020-01-16T08:11:46.000Z">
<meta property="article:modified_time" content="2020-01-17T03:11:37.169Z">
<meta property="article:author" content="guanzhilin">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;uk-1259555870.cos.eu-frankfurt.myqcloud.com&#x2F;20200113150533.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/01/16/Redis面试常见基本问题/"/>





  <title>Redis面试常见基本问题 | gzlBlog</title>
  








<meta name="generator" content="Hexo 4.1.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">gzlBlog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/16/Redis%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="guanzhilin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gzlBlog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Redis面试常见基本问题</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-16T16:11:46+08:00">
                2020-01-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="1-基础"><a href="#1-基础" class="headerlink" title="1.基础"></a>1.基础</h1><h2 id="1-1-什么是Redis？"><a href="#1-1-什么是Redis？" class="headerlink" title="1.1 什么是Redis？"></a>1.1 什么是Redis？</h2><p>Redis的全称是：Remote Dictionary Server，本质上是一个 Key-Value 类型的内存数据库。</p>
<p>整个数据库统统<strong>加载在内存</strong>当中进行操作，定期通过异步操作把数据库数据保存在硬盘。因为是纯内存操作，Redis 的性能非常出色。</p>
<h2 id="1-2-Redis的优劣势？"><a href="#1-2-Redis的优劣势？" class="headerlink" title="1.2 Redis的优劣势？"></a>1.2 Redis的优劣势？</h2><p>优势：</p>
<ul>
<li>纯内存读写操作，性能好。</li>
<li>支持多种数据结构。</li>
<li>单线程，不用担心竞争</li>
<li>特性丰富，支持发布订阅、过期、sentinel等功能。</li>
</ul>
<p>劣势：</p>
<ul>
<li>容量受物理内存限制，不能用作海量数据的高性能读写。</li>
</ul>
<h2 id="1-3-Redis和Memcached比较"><a href="#1-3-Redis和Memcached比较" class="headerlink" title="1.3 Redis和Memcached比较"></a>1.3 Redis和Memcached比较</h2><p>Memcached早年被很多公司使用，现在内存越来越便宜，基本都是用Redis。Redis被认为是Memcached的替代者，优势有：</p>
<ul>
<li>memcached值均为简单字符串，redis支持更丰富的类型</li>
<li>redis性能更好（速度快，内存大）Memcached内存限制为1MB，而Redis可以达到1GB</li>
<li>redis可以持久化</li>
<li>Memcached集群功能不好，没有原生集群模式</li>
</ul>
<p>劣势有：</p>
<ul>
<li>redis只是用一个核，而memcached使用多核，在大数据处理上，memecached效率要好一些。</li>
</ul>
<h2 id="1-4-Redis支持哪些数据类型"><a href="#1-4-Redis支持哪些数据类型" class="headerlink" title="1.4 Redis支持哪些数据类型"></a>1.4 Redis支持哪些数据类型</h2><p>对象：</p>
<ul>
<li>字符串对象，支持int、raw、embstr编码</li>
<li>列表对象，支持ziplist和linkedlist编码</li>
<li>哈希对象，支持ziplist和hashtable</li>
<li>集合对象，支持intset和hashtable</li>
<li>有序集合对象，支持ziplist和skiplist</li>
</ul>
<h1 id="2-缓存相关"><a href="#2-缓存相关" class="headerlink" title="2. 缓存相关"></a>2. 缓存相关</h1><h2 id="2-1-什么是缓存雪崩？"><a href="#2-1-什么是缓存雪崩？" class="headerlink" title="2.1 什么是缓存雪崩？"></a>2.1 什么是缓存雪崩？</h2><p>首先，为什么要使用缓存？</p>
<img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200113150533.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;">

<p>缓存区域的大小是有限的，为了避免数量膨胀，redis采取了<a href="https://jiangren.work/2020/01/04/Redis设计与实现3-数据库/#3-过期键" target="_blank" rel="noopener">过期删除策略</a>。但是如果缓存数据设置的过期时间是相同的，会导致这些缓存<strong>同时失效</strong>，所有请求全部跑向数据库，造成巨大冲击。这就是<strong>缓存雪崩</strong>。</p>
<p>发生的原因可能是：</p>
<ul>
<li>Redis挂掉。</li>
<li>由于过期键时间问题，导致同时失效。</li>
</ul>
<h2 id="2-2-如何解决缓存雪崩？"><a href="#2-2-如何解决缓存雪崩？" class="headerlink" title="2.2 如何解决缓存雪崩？"></a>2.2 如何解决缓存雪崩？</h2><p>对于过期键失效问题：</p>
<ul>
<li>在缓存的时候给过期时间加上一个<strong>随机值</strong>，这样就会大幅度的<strong>减少缓存在同一时间过期</strong>。</li>
</ul>
<p>对于redis挂掉的问题：</p>
<ul>
<li>主从服务器+sentinel+集群模式，保证有继承人存在，及时推举。</li>
<li>如果redis真的挂了，可以设置<strong>本地缓存+限流</strong></li>
<li>事发后，利用持久化特性，尽快从磁盘上加载数据，恢复缓存。</li>
</ul>
<h2 id="2-3-什么是缓存穿透？"><a href="#2-3-什么是缓存穿透？" class="headerlink" title="2.3 什么是缓存穿透？"></a>2.3 什么是缓存穿透？</h2><p>缓存穿透是指查询一个一定<strong>不存在的数据</strong>。由于缓存不命中，并且出于容错考虑，如果从<strong>数据库查不到数据则不写入缓存</strong>，这将导致这个不存在的数据<strong>每次请求都要到数据库去查询</strong>，失去了缓存的意义。</p>
<img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200113152209.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;">

<h2 id="2-4-如何解决缓存穿透？"><a href="#2-4-如何解决缓存穿透？" class="headerlink" title="2.4 如何解决缓存穿透？"></a>2.4 如何解决缓存穿透？</h2><ul>
<li>使用<strong>布隆过滤器</strong></li>
<li>当我们从数据库找不到的时候，我们也将这个<strong>空对象设置到缓存里边去</strong>。下次再请求的时候，就可以从缓存里边获取了。这种情况我们一般会将空对象设置一个<strong>较短的过期时间</strong></li>
</ul>
<p>布隆过滤器的原理解释<a href="https://www.cnblogs.com/rinack/p/9712477.html" target="_blank" rel="noopener">https://www.cnblogs.com/rinack/p/9712477.html</a></p>
<h2 id="2-5-如何解决缓存与数据库双写不一致？"><a href="#2-5-如何解决缓存与数据库双写不一致？" class="headerlink" title="2.5 如何解决缓存与数据库双写不一致？"></a>2.5 如何解决缓存与数据库双写不一致？</h2><p><a href="https://blog.csdn.net/sun_qiangwei/article/details/80095980" target="_blank" rel="noopener">https://blog.csdn.net/sun_qiangwei/article/details/80095980</a></p>
<p>在写更新数据时，我们要进行两步操作：<strong>删除缓存</strong>和<strong>更新数据库</strong>（一般不使用更新缓存，都是直接删除），现在的问题就是：这两步先做哪一个？</p>
<ol>
<li>先更新数据库，再删除缓存</li>
<li>先删除缓存，再更新数据库</li>
</ol>
<p><strong>如果是1</strong>，则</p>
<ul>
<li>当原子性破坏时（更新了库，没删缓存），<strong>导致数据不一致</strong></li>
<li>并发场景<strong>出现问题的概率较低</strong>，仅发生在<strong>缓存失效时</strong><ol>
<li>线程A查询数据库，得到旧值</li>
<li>线程B将新值写入数据库</li>
<li>线程B删除缓存</li>
<li>线程A将查到的旧值写入缓存</li>
</ol>
</li>
</ul>
<p>为什么说发生概率低呢？</p>
<ul>
<li>仅发生在缓存失效时</li>
<li>写操作一般比较慢，很难出现c在d前面的情况。</li>
</ul>
<p><strong>如果是2</strong>，则：</p>
<ul>
<li>原子性被破坏时，不影响一致性</li>
<li>并发时，问题很大<ol>
<li>线程A删除缓存</li>
<li>线程B查询时缓存不存在，于是到数据库取了一个旧值</li>
<li>线程B将旧值写入缓存</li>
<li>线程A将新值写入数据库</li>
</ol>
</li>
</ul>
<p>如何保证并发下的一致呢？</p>
<p>将删除缓存、修改数据库、读取缓存等的操作积压到<strong>队列</strong>里边，实现<strong>串行化</strong>。</p>
<img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200113154703.png"  style="zoom:75%;display: block; margin: 0px auto; vertical-align: middle;">

<h1 id="3-线程模型"><a href="#3-线程模型" class="headerlink" title="3. 线程模型"></a>3. 线程模型</h1><h2 id="3-1-为什么Redis是单线程？"><a href="#3-1-为什么Redis是单线程？" class="headerlink" title="3.1 为什么Redis是单线程？"></a>3.1 为什么Redis是单线程？</h2><p>首先CPU的性能并不是瓶颈，主要考虑本地内存和网络带宽。其次，单线程可以避免线程切换的资源消耗和竞争问题，有利于性能提升。</p>
<h2 id="3-2-介绍一下IO多路复用"><a href="#3-2-介绍一下IO多路复用" class="headerlink" title="3.2 介绍一下IO多路复用"></a>3.2 介绍一下IO多路复用</h2><p>IO多路复用的原理是：存在一个接线员，当有客户连接时，接线员接收连接，分派到制定执行函数，然后接着监听。这样就可以避免处理某一个连接而阻塞其他用户的情况。</p>
<img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200113160426.png"/>

<hr>
<p>Redis的I/O多路复用程序的所有功能都是<strong>通过包装常见的select、epoll这些I/O多路复用函数库来实现的</strong>。由于IO复用程序提供了统一的接口，所以<strong>底层实现方法可以互换。</strong></p>
<h2 id="3-3-介绍一下redis线程模型的处理流程"><a href="#3-3-介绍一下redis线程模型的处理流程" class="headerlink" title="3.3 介绍一下redis线程模型的处理流程"></a>3.3 介绍一下redis线程模型的处理流程</h2><p>Redis基于Reactor模式开发了自己的网络事件处理器：这个处理器被称为<strong>文件事件处理器（file event handler）</strong>。</p>
<p>文件事件处理器包括：</p>
<ul>
<li>套接字</li>
<li>IO复用程序</li>
<li>文件事件分派器</li>
<li>事件处理器</li>
</ul>
<p>事件处理器包括：</p>
<ul>
<li>连接应答处理器</li>
<li>命令请求处理器</li>
<li>命令回复处理器</li>
</ul>
<p>详情参见<a href="https://jiangren.work/2020/01/05/Redis设计与实现5-事件/#1-2-IO多路复用程序的实现" target="_blank" rel="noopener">事件处理器讲解</a></p>
<h1 id="4-数据删除与淘汰机制"><a href="#4-数据删除与淘汰机制" class="headerlink" title="4. 数据删除与淘汰机制"></a>4. 数据删除与淘汰机制</h1><h2 id="4-1-介绍一下redis的过期删除策略"><a href="#4-1-介绍一下redis的过期删除策略" class="headerlink" title="4.1 介绍一下redis的过期删除策略"></a>4.1 介绍一下redis的过期删除策略</h2><p><strong>（1）惰性删除</strong></p>
<p>放着不管，每次从键空间获取时检查是否过期，过期就删除。</p>
<p><strong>对CPU最友好</strong>，<strong>但浪费内存</strong>。如果数据库中有很多过期键，而这些过期键永远也不会被访问的话，他们就会永远占据空间，可视为<strong>内存泄漏</strong>。比如一些和时间有关的数据（日志）。</p>
<p><strong>（2）定期删除</strong></p>
<p>每隔一段时间，程序检查一次数据库，删除过期键。</p>
<p><strong>对CPU和内存是一种折中</strong>。通过选择较为空闲的时间点来处理过期键，减少CPU压力。同时也能及时释放内存，避免内存泄漏。</p>
<p>在redis中由周期函数severCron负责，它在规定的时间内，<strong>分多次遍历服务器中的各个数据库</strong>，从数据库的expires字典中<strong>随机检查一部分键的过期时间</strong>，并删除其中的过期键。他会记录检查进度，在<strong>下一次检查时接着上一次的进度进行处理</strong>。比如说，如果当前函数在遍历10号数据库时返回了，那么下次就会从11号数据库开始工作。</p>
<h2 id="4-2-介绍一下Redis的内存淘汰机制"><a href="#4-2-介绍一下Redis的内存淘汰机制" class="headerlink" title="4.2 介绍一下Redis的内存淘汰机制"></a>4.2 介绍一下Redis的内存淘汰机制</h2><p>惰性删除和定期删除依然可能保留大量过期键，这时候需要用到内存淘汰机制。内存淘汰机制有6个：</p>
<ul>
<li><strong>noeviction</strong>：eviction是驱逐的意思，当内存不足以容纳新写入数据时，新写入操作会报错。</li>
<li><strong>allkeys-lru</strong>：当内存不足以容纳新写入数据时，在<strong>键空间</strong>中，移除最近最少使用的 key :ok_hand::ok_hand:</li>
<li><strong>allkeys-random</strong>：当内存不足以容纳新写入数据时，在<strong>键空间</strong>中，随机移除某个 key。</li>
<li><strong>volatile-lru</strong>：[ˈvɒlətaɪl]易挥发的，易丢失的。当内存不足以容纳新写入数据时，在<strong>设置了过期时间的键空间</strong>中，移除最近最少使用的 key。</li>
<li><strong>volatile-random</strong>：当内存不足以容纳新写入数据时，在<strong>设置了过期时间的键空间</strong>中，<strong>随机移除</strong>某个 key。:ok_hand:</li>
<li><strong>volatile-ttl</strong>：当内存不足以容纳新写入数据时，在<strong>设置了过期时间的键空间</strong>中，有<strong>更早过期时间</strong>的 key 优先移除。:ok_hand:</li>
</ul>
<h2 id="4-3-写一个LRU算法"><a href="#4-3-写一个LRU算法" class="headerlink" title="4.3 写一个LRU算法"></a>4.3 写一个LRU算法</h2><p>我的博客有总结，是一道Leetcode题目，C++版本：</p>
<p><a href="https://jiangren.work/2019/09/05/Leetcode题目总结7-容器的应用/" target="_blank" rel="noopener">Leetcode146-LRU缓存机制</a></p>
<h1 id="5-Redis高并发和高可用"><a href="#5-Redis高并发和高可用" class="headerlink" title="5. Redis高并发和高可用"></a>5. Redis高并发和高可用</h1><h2 id="5-1-Redis的高并发是如何实现的？"><a href="#5-1-Redis的高并发是如何实现的？" class="headerlink" title="5.1 Redis的高并发是如何实现的？"></a>5.1 Redis的高并发是如何实现的？</h2><p>首先<strong>从程序编写的角度上</strong>来说，</p>
<ul>
<li>Redis是纯内存数据库，读写速度快，</li>
<li>采用了非阻塞IO复用，</li>
<li>采用了单线程减少切换，</li>
<li>采用了优秀的数据结构设计，</li>
<li>设计了分离的文件事件处理器和文件事件分派器。</li>
</ul>
<p>然后，<strong>从布局架构上</strong>来说，实现<strong>高并发</strong>主要依靠<strong>主从架构</strong>（<strong>单线程多进程</strong>），比如<strong>单机写数据，多机查数据</strong>。单机能达到几万QPS(queries per sec)，多个从实例能达到10W的QPS。</p>
<p>更进一步，可以采用集群，不仅能实现高并发，还能容纳大量数据。</p>
<h2 id="5-2-Redis的高可用是如何实现的？"><a href="#5-2-Redis的高可用是如何实现的？" class="headerlink" title="5.2 Redis的高可用是如何实现的？"></a>5.2 Redis的高可用是如何实现的？</h2><p>高可用性指<strong>系统无中断地执行其功能的能力</strong>。Redis实现高可用依靠的是Sentinel哨兵机制。Sentinel<strong>本质上只是一个运行在特殊模式下的Redis服务器</strong>，是一个进程。</p>
<p><strong>Sentinel作用：</strong></p>
<ul>
<li>监控Redis整体是否正常运行。</li>
<li>某个节点出问题时，<strong>通知给其他进程</strong>（比如他的客户端）。</li>
<li>主服务器下线时，在从服务器中<strong>选举</strong>出一个新的主服务器。</li>
</ul>
<p><strong>Sentinel监督服务器：</strong></p>
<ol>
<li>与主服务器构建连接，每10秒向主服务器发送INFO命令，分析回复消息分析主服务器状态。</li>
<li>从主服务器状态中获取从服务器信息，并与他们建立连接。达到全覆盖的目的。</li>
</ol>
<p><strong>Sentinel互相监督：</strong></p>
<ol>
<li>Sentinel和服务器之间建立hello频道连接</li>
<li>Sentinel在hello频道发送信息时会被其他Sentinel发现，达到握手的目的。</li>
<li>发现后，Sentinel之间建立连接，形成环形网络。</li>
</ol>
<p><strong>Sentinel监督下线：</strong></p>
<ul>
<li>按频率向所有创建连接的实例发送PING，查看是否回复PONG来判断是否在线，不回复则<strong>标记为主观下线状态</strong>。</li>
<li>向其他Sentinel询问，如果足够数量的Sentinel也标记为下线状态，则改为<strong>客观下线</strong>。</li>
</ul>
<p><strong>Sentinel下线补救措施：</strong></p>
<p><strong>（1）选举领头的Sentinel</strong></p>
<p>过程：一个Sentinel向另一个Sentinel发送设置请求命令。<strong>最先向目标Sentinel</strong>发送设置要求的源Sentinel将成为目标Sentinel的局部领头Sentinel，而之后接收到的所有设置要求都会被目标Sentinel拒绝。</p>
<p>如果有某个Sentinel<strong>被半数</strong>以上的Sentinel设置成了局部领头Sentinel，那么这个Sentinel成为领头Sentinel。</p>
<p><strong>（2）故障转移</strong></p>
<ol>
<li>从已下线的主服务器的从服务器中<strong>拔举</strong>一个作为主服务器。标准：<strong>偏移量最大</strong></li>
<li>让已下线主服务器属下的所有从服务器改为复制新的主服务器</li>
<li>将已下线主服务器设置为新的主服务器的从服务器，当这个旧的主服务器重新上线时，它就会成为新的主服务器的从服务器。</li>
</ol>
<h1 id="6-多机架构"><a href="#6-多机架构" class="headerlink" title="6. 多机架构"></a>6. 多机架构</h1><h2 id="6-1-Redis有哪些多机架构？"><a href="#6-1-Redis有哪些多机架构？" class="headerlink" title="6.1 Redis有哪些多机架构？"></a>6.1 Redis有哪些多机架构？</h2><p>不考虑中间件，原生的架构有<strong>主从复制架构</strong>和<strong>集群架构</strong>。</p>
<h2 id="6-2-介绍一下复制过程"><a href="#6-2-介绍一下复制过程" class="headerlink" title="6.2 介绍一下复制过程"></a>6.2 介绍一下复制过程</h2><p>Redis中复制有新老两版。</p>
<p>老版：分为同步和命令传播两个阶段。</p>
<hr>
<p><strong>老版：</strong></p>
<p><strong>在同步阶段：</strong></p>
<ol>
<li>从机向主机发送SYNC命令</li>
<li>主机收到后，执行BGSAVE生成RDB文件，并使用缓冲区记录现在开始执行的所有写操作。</li>
<li>将RDB文件发给从服务器</li>
<li>将缓冲区内容发送给从服务器</li>
</ol>
<p><strong>在命令传播阶段：</strong></p>
<p>主服务器将自己执行的写命令发送给从服务器，让他执行相同的命令</p>
<p><strong>缺陷：</strong></p>
<p>初次复制效果较好，但断线后重连复制效率很低，需要全部重录RDB文件。</p>
<hr>
<p><strong>新版：</strong></p>
<p>分为完整重同步和部分重同步，前者和旧版一样。部分重同步有三个部分：</p>
<ul>
<li>主从服务器的复制偏移量</li>
<li>主服务器的复制积压缓冲区</li>
<li>服务器的运行ID</li>
</ul>
<p>主服务器和从服务器会分别维护一个复制偏移量，通过对比偏移量来知道主从服务器是否处于一致状态：</p>
<ul>
<li>主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N。</li>
<li>从服务器每次收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量的值加上N。</li>
</ul>
<p>复制积压缓冲区是由主服务器维护的一个<strong>固定长度</strong>（fixed-size）先进先出（FIFO）队列。当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器，还会<strong>将写命令入队到复制积压缓冲区里面</strong>。同时，主服务器也会向积压缓冲区添加偏移量。重新上线时根据偏移量决定如何重同步：</p>
<ul>
<li>下线后，数据长度超过了缓冲区，导致溢出，说明下线时间太长，执行完全重同步。</li>
<li>否则，部分重同步。</li>
</ul>
<p>而主服务器ID则帮助重新上线的从服务器识别，</p>
<ul>
<li>如果ID和从服务器记录的相同，则表示<strong>之前同步的主服务器就是这个</strong>，执行部分重同步。</li>
<li>如果ID不同，则表明从<strong>服务器断线之前复制的主服务器并不是当前连接的这个主服务器</strong>，执行完整重同步操作。</li>
</ul>
<h2 id="6-3-介绍一下集群"><a href="#6-3-介绍一下集群" class="headerlink" title="6.3 介绍一下集群"></a>6.3 介绍一下集群</h2><p>集群通过分片（sharding）来进行数据共享，并提供复制和故障转移功能，保证高可用性。</p>
<p><strong>集群的结构</strong>是：多个节点（node）组成一个集群，节点是Redis中数据存储的单位，在刚开始的时候，每个节点都是相互独立的。通过<code>CLUSTER MEET</code>命令相互握手，组成集群。</p>
<p><strong>集群数据的存储方式</strong>是：集群的整个数据库被分一万多个槽（slot）<strong>，</strong>数据库中的每个键都属于槽的其中一个。当所有槽都有节点在处理时，集群处于上线状态。</p>
<h2 id="6-4-集群的通信方式是怎样的？"><a href="#6-4-集群的通信方式是怎样的？" class="headerlink" title="6.4 集群的通信方式是怎样的？"></a>6.4 集群的通信方式是怎样的？</h2><p>集群依靠消息通信，消息有5种：MEET, PING, PONG, FAIL, PUBLISH。</p>
<p>Redis集群中的各个节点通过<strong>Gossip协议</strong>来交换各自关于不同节点的状态信息，其中Gossip协议由MEET、PING、PONG三种消息实现。</p>
<hr>
<p>所谓Gossip是八卦消息的意思，在Redis中，发送每次发送MEET、PING、PONG消息时，发送者都从自己的已知节点列表中<strong>随机选出两个节点</strong>（可以是主节点或者从节点），保存到一个特殊结构体中。</p>
<p>接受者接收到MEET、PING、PONG消息时，根据保存的两个节点是否认识来选择进行哪种操作：</p>
<ul>
<li>不认识，说明接收者<strong>第一次接触被选中节点</strong>，则接收者与被选中节点握手</li>
<li>认识，根据结构信息进行更新。</li>
</ul>
<p>比如A节点发送的PING给B，携带了CD两个节点，然后B回复PONG携带了EF两个节点，这样就完成了ABCDEF六个节点的信息交换。<strong>每个节点按照周期向不同节点传播PING-PONG信息，就能完成整个集群的状态更新。</strong></p>
<hr>
<p>如果节点很多，则Gossip消息比较慢，而主节点下线的消息需要立即通知给所有人。FAIL消息的正文只包含已下线的节点名称，直接通知给所有已知节点。</p>
<p><img src="https://cdn.cnbj1.fds.api.mi-img.com/book/images/fcccd0065c411e2492d097f9bb0fb378?thumb=1&w=1024&h=1024" alt=""></p>
<p><img src="https://cdn.cnbj1.fds.api.mi-img.com/book/images/7fb4b031c86ff72f6478b8e16718b43d?thumb=1&w=1024&h=1024" alt=""></p>
<hr>
<p>接收到PUBLISH命令的节点<strong>不仅会向channel频道发送消息message，它还会向集群广播一条PUBLISH消息，所有接收到这条PUBLISH消息的节点都会向channel频道发送message消息</strong>。</p>
<p>也就是说，向集群发送<code>PUBLISH</code>，会导致集群所有节点都向channel发送message消息。</p>
<p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200112133931.png" alt=""></p>
<h2 id="6-5-集群分片的原理是什么"><a href="#6-5-集群分片的原理是什么" class="headerlink" title="6.5 集群分片的原理是什么?"></a>6.5 集群分片的原理是什么?</h2><p>Redis引入了哈希槽的概念，通过槽指派的方式存储数据。</p>
<p>Redis集群有$2^{14}=16384$个哈希槽,每个key通过CRC16校验后对16384取模来决定放置哪个槽<code>slot = CRC16(key) &amp; 16383</code>，集群的每个节点负责一部分hash槽。</p>
<p><strong>使用哈希槽的好处就在于可以方便的添加或移除节点。</strong></p>
<ol>
<li>当需要增加节点时，只需要把其他节点的某些哈希槽挪到新节点就可以了；</li>
<li>当需要移除节点时，只需要把移除节点上的哈希槽挪到其他节点就行了。</li>
</ol>
<p>CRC16算法能分配65535个槽位，但作为包发送太臃肿，一般情况下一个redis集群不会有超过1000个master节点，所以采用$1/4$</p>
<h2 id="6-6-集群扩容和收缩是怎么实现的？"><a href="#6-6-集群扩容和收缩是怎么实现的？" class="headerlink" title="6.6 集群扩容和收缩是怎么实现的？"></a>6.6 集群扩容和收缩是怎么实现的？</h2><p>集群的伸缩是通过重新分片的方式实现的，重新分片操作可以将<strong>任意数量已经指派给某个节点（源节点）的槽改为指派给另一个节点（目标节点）</strong>，并且相关槽所属的键值对也会从源节点被移动到目标节点。</p>
<p>重新分片操作可以<strong>在线（online）进行</strong>，在重新分片的过程中，集群不需要下线，并且<strong>源节点和目标节点都可以继续处理命令请求</strong>。</p>
<p>重新分片由redis-trib负责，步骤如下：</p>
<ol>
<li>trib向源节点发送命令，包含了执行迁移的槽slot，要迁移键的数量count。</li>
<li>源节点返回属于槽slot的count个键。</li>
<li>对于每个返回键，trib向源节点发送一个MIGRATE命令</li>
<li>源节点根据MIGRATE命令将键迁移到目标节点，</li>
</ol>
<p><img src="https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200112105535.png" alt=""></p>
<p>如果多槽，则分别对不同槽执行多次。</p>
<h1 id="7-持久化"><a href="#7-持久化" class="headerlink" title="7. 持久化"></a>7. 持久化</h1><h2 id="7-1-为什么采用持久化？"><a href="#7-1-为什么采用持久化？" class="headerlink" title="7.1 为什么采用持久化？"></a>7.1 为什么采用持久化？</h2><p>持久化有两个作用：方便主从复制和灾难恢复。</p>
<p>由于Redis的数据全都放在内存而不是磁盘里面，如果Redis挂了，没有配置持久化的话，重启的时候数据会全部丢失。所以需要将数据写入磁盘，本地化保存。</p>
<h2 id="7-2-持久化的方式有哪些？"><a href="#7-2-持久化的方式有哪些？" class="headerlink" title="7.2 持久化的方式有哪些？"></a>7.2 持久化的方式有哪些？</h2><p>有RDB持久化和AOF持久化。</p>
<hr>
<p>RDB持久化：</p>
<p>将数据库状态以RDB文件格式保存。可以采用SAVE命令阻塞服务器进程，也可以用BGSAVE命令fork一个子进程。</p>
<p>通过周期性函数serverCron不断的判断保存条件，如果条件满足就保存。</p>
<hr>
<p>AOF持久化：</p>
<p>AOF(Append Only File)<strong>记录Redis服务器所执行的写命令</strong>。AOF实现原理是<strong>命令追加</strong>和<strong>文件写入同步</strong>，</p>
<ul>
<li>命令追加：服务器执行完一个命令后，会以协议格式将命令<strong>追加到服务器状态aof_buf缓冲区的结尾</strong></li>
<li>文件写入同步：服务器每次结束一个事件循环之前都<strong>考虑是否需要将<code>aof_buf</code>缓冲区中的内容写入和保存到AOF文件里面</strong>。</li>
</ul>
<p>AOF还原时需要建立一个不带网络连接的伪客户端，因为Redis的命令只能在客户端上下文中执行。</p>
<h2 id="7-3-AOF的重写是什么意思？"><a href="#7-3-AOF的重写是什么意思？" class="headerlink" title="7.3 AOF的重写是什么意思？"></a>7.3 AOF的重写是什么意思？</h2><p>随着时间的增长，AOF文件的大小将会越来越大。通过重写，Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件，新旧两个<strong>AOF文件保存的数据库状态完全相同</strong>，但新的文件体积更小。</p>
<p>重写的策略是：<strong>从数据库中读取键现在的值，然后用一条命令去记录键值对</strong>。相当于折叠命令，只求最终结果。</p>
<p>此外，子进程AOF重写时，主进程也在写命令，导致两者状态不一致。因此，<strong>Redis服务器设置了一个AOF重写缓冲区</strong>，当Redis服务器执行完一个写命令之后，它会<strong>同时</strong>将这个写命令发送给<strong>AOF缓冲区</strong>和<strong>AOF重写缓冲区</strong>。</p>
<h2 id="7-4-AOF和RDB优劣势比较"><a href="#7-4-AOF和RDB优劣势比较" class="headerlink" title="7.4 AOF和RDB优劣势比较"></a>7.4 AOF和RDB优劣势比较</h2><p>RDB</p>
<p>优势：完整，恢复迅速</p>
<p>劣势：消耗资源大，每次保存的间隔周期长，丢失数据多</p>
<hr>
<p>AOF</p>
<p>优势：保存间隔短，丢失数据少，系统资源消耗少。保存格式清晰，适合误操作的恢复。</p>
<p>劣势：恢复速度较慢，需要建立伪客户端，如果发生崩溃的情况需要尽快恢复，最好采用RDB。重写后数据保存不一定完整，可能有BUG。</p>
<h1 id="8-事务"><a href="#8-事务" class="headerlink" title="8. 事务"></a>8. 事务</h1><h2 id="8-1-什么是事务？"><a href="#8-1-什么是事务？" class="headerlink" title="8.1 什么是事务？"></a>8.1 什么是事务？</h2><p>Redis通过MULTI、EXEC、WATCH等命令来实现事务（transaction）功能。事务将<strong>一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制</strong>，并且在事务执行期间，<strong>服务器不会中断事务</strong>而改去执行其他客户端的命令请求。</p>
<h2 id="8-2-Redis中事务是如何实现的？"><a href="#8-2-Redis中事务是如何实现的？" class="headerlink" title="8.2 Redis中事务是如何实现的？"></a>8.2 Redis中事务是如何实现的？</h2><p>事务从开始到结束经历三个阶段：</p>
<ol>
<li>事务开始</li>
<li>事务入队</li>
<li>事务执行</li>
</ol>
<hr>
<p>通过MULTI命令可以将执行该命令的客户端<strong>从非事务状态切换至事务状态</strong>，在是事务状态下，</p>
<ul>
<li>如果客户端发送EXEC，DISCARD，WATCH，MULTI这四个命令，则立即执行。</li>
<li>如果发送的是其他命令，则放到事务队列里面，向客户端返回QUEUED回复。</li>
</ul>
<hr>
<p>每个Redis客户端都有自己的<strong>事务状态结构体</strong>，每个结构体中又包含了一个<strong>事务队列</strong>和<strong>已入队命令计数器。</strong>在事务队列中包含了<strong>具体的命令cmd</strong>。</p>
<hr>
<p>当一个处于事务状态的客户端向服务器发送EXEC命令时，这个EXEC命令将立即被服务器执行。<strong>服务器会遍历这个客户端的事务队列，执行队列中保存的所有命令，最后将执行命令所得的结果全部返回给客户端。</strong>过程是：</p>
<ol>
<li>创建空白回复队列</li>
<li>抽取一条命令，读取参数、参数个数以及要执行的函数</li>
<li>行命令，取得返回值</li>
<li>将返回值追加到1中的队列末尾，重复步骤2</li>
<li>完成后，清除事务标志，回到非事务状态，同时清空计数器和释放事务队列。</li>
</ol>
<h2 id="8-3-事务中的乐观锁是什么？"><a href="#8-3-事务中的乐观锁是什么？" class="headerlink" title="8.3 事务中的乐观锁是什么？"></a>8.3 事务中的乐观锁是什么？</h2><p>乐观锁，也称CAS(check and set)，属于无罪推定原则，每次别人拿数据都假定他不修改，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。</p>
<p>Redis中通过WATCH来实现，它可以<strong>在EXEC命令执行之前</strong>，<strong>监视任意数量的数据库键</strong>，并在EXEC命令执行时，<strong>检查被监视的键是否被其他客户修改过，</strong>如果是的话，<strong>服务器将拒绝执行事务</strong>，并向客户端返回代表事务执行失败的空回复。</p>
<h2 id="8-4-WATCH命令的原理是什么？"><a href="#8-4-WATCH命令的原理是什么？" class="headerlink" title="8.4 WATCH命令的原理是什么？"></a>8.4 WATCH命令的原理是什么？</h2><p>每个Redis数据库都保存着一个<code>watched_keys</code>字典，这个字典的<strong>键是某个被WATCH命令监视的数据库键</strong>，而<strong>字典的值则是一个链表，链表中记录了所有监视相应数据库键的客户端</strong>。</p>
<p>对数据库<strong>执行修改命令</strong>时，会对字典进行检查。<strong>查看当前命令修改的键是否在<code>watched_keys</code>字典中</strong>，如果有，且事务标志被打开<strong>，表示该客户端的事务安全性已经被破坏</strong>。将<code>REDIS_DIRTY_CAS</code>标识打开。</p>
<p>在EXEC命令执行时，检查<code>REDIS_DIRTY_CAS</code>标志是否打开判断是否应该执行。</p>
<h2 id="8-5-解释一下事务的ACID性质"><a href="#8-5-解释一下事务的ACID性质" class="headerlink" title="8.5 解释一下事务的ACID性质"></a>8.5 解释一下事务的ACID性质</h2><p>所谓ACID性质是指：<strong>有原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、耐久性（Durability）。</strong></p>
<p><strong>原子性</strong>：事务在执行前用WATCH检查，命令有没有被插入执行过。</p>
<p><strong>一致性</strong>：<strong>入队错误</strong>：事务入队时命令格式不正确，则Redis拒绝执行；<strong>执行错误</strong>：执行时操作不正确，会被服务器识别，并做错误处理，所以这些出错命令不会对数据库做任何修改；<strong>停机后</strong>根据持久化，也能还原为一致状态。</p>
<p><strong>隔离性</strong>：单线程，且事务不会被打断，串行的方式保证不同事务的隔离性（不保证键不会冲突）</p>
<p><strong>耐久性</strong>：不一定，得看哪种持久化，只有always模式下的AOF才有。（每次执行命令都会调用同步函数）</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Redis/" rel="tag"># Redis</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/01/04/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97/" rel="next" title="剑指offer 字符串的全排列">
                <i class="fa fa-chevron-left"></i> 剑指offer 字符串的全排列
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">guanzhilin</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-基础"><span class="nav-number">1.</span> <span class="nav-text">1.基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-什么是Redis？"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 什么是Redis？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-Redis的优劣势？"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 Redis的优劣势？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-Redis和Memcached比较"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 Redis和Memcached比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-Redis支持哪些数据类型"><span class="nav-number">1.4.</span> <span class="nav-text">1.4 Redis支持哪些数据类型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-缓存相关"><span class="nav-number">2.</span> <span class="nav-text">2. 缓存相关</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-什么是缓存雪崩？"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 什么是缓存雪崩？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-如何解决缓存雪崩？"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 如何解决缓存雪崩？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-什么是缓存穿透？"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 什么是缓存穿透？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-如何解决缓存穿透？"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 如何解决缓存穿透？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-如何解决缓存与数据库双写不一致？"><span class="nav-number">2.5.</span> <span class="nav-text">2.5 如何解决缓存与数据库双写不一致？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-线程模型"><span class="nav-number">3.</span> <span class="nav-text">3. 线程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-为什么Redis是单线程？"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 为什么Redis是单线程？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-介绍一下IO多路复用"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 介绍一下IO多路复用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-介绍一下redis线程模型的处理流程"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 介绍一下redis线程模型的处理流程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-数据删除与淘汰机制"><span class="nav-number">4.</span> <span class="nav-text">4. 数据删除与淘汰机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-介绍一下redis的过期删除策略"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 介绍一下redis的过期删除策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-介绍一下Redis的内存淘汰机制"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 介绍一下Redis的内存淘汰机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-写一个LRU算法"><span class="nav-number">4.3.</span> <span class="nav-text">4.3 写一个LRU算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-Redis高并发和高可用"><span class="nav-number">5.</span> <span class="nav-text">5. Redis高并发和高可用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-Redis的高并发是如何实现的？"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 Redis的高并发是如何实现的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-Redis的高可用是如何实现的？"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 Redis的高可用是如何实现的？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-多机架构"><span class="nav-number">6.</span> <span class="nav-text">6. 多机架构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-Redis有哪些多机架构？"><span class="nav-number">6.1.</span> <span class="nav-text">6.1 Redis有哪些多机架构？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-介绍一下复制过程"><span class="nav-number">6.2.</span> <span class="nav-text">6.2 介绍一下复制过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-介绍一下集群"><span class="nav-number">6.3.</span> <span class="nav-text">6.3 介绍一下集群</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-4-集群的通信方式是怎样的？"><span class="nav-number">6.4.</span> <span class="nav-text">6.4 集群的通信方式是怎样的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-5-集群分片的原理是什么"><span class="nav-number">6.5.</span> <span class="nav-text">6.5 集群分片的原理是什么?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-6-集群扩容和收缩是怎么实现的？"><span class="nav-number">6.6.</span> <span class="nav-text">6.6 集群扩容和收缩是怎么实现的？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-持久化"><span class="nav-number">7.</span> <span class="nav-text">7. 持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-为什么采用持久化？"><span class="nav-number">7.1.</span> <span class="nav-text">7.1 为什么采用持久化？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-持久化的方式有哪些？"><span class="nav-number">7.2.</span> <span class="nav-text">7.2 持久化的方式有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-AOF的重写是什么意思？"><span class="nav-number">7.3.</span> <span class="nav-text">7.3 AOF的重写是什么意思？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-4-AOF和RDB优劣势比较"><span class="nav-number">7.4.</span> <span class="nav-text">7.4 AOF和RDB优劣势比较</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-事务"><span class="nav-number">8.</span> <span class="nav-text">8. 事务</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1-什么是事务？"><span class="nav-number">8.1.</span> <span class="nav-text">8.1 什么是事务？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2-Redis中事务是如何实现的？"><span class="nav-number">8.2.</span> <span class="nav-text">8.2 Redis中事务是如何实现的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-3-事务中的乐观锁是什么？"><span class="nav-number">8.3.</span> <span class="nav-text">8.3 事务中的乐观锁是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-4-WATCH命令的原理是什么？"><span class="nav-number">8.4.</span> <span class="nav-text">8.4 WATCH命令的原理是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-5-解释一下事务的ACID性质"><span class="nav-number">8.5.</span> <span class="nav-text">8.5 解释一下事务的ACID性质</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">guanzhilin</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
